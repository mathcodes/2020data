{"ast":null,"code":"import { getDataFromRegion, metricText, parseDate, simplifyName } from './utils';\nimport * as str from './strings';\nimport { plotSpecificTypes } from './plot_types';\nimport i18n from '../data/i18n.yml';\nimport diseases from '../data/other_diseases_stats.yml';\nexport const generatePlotData = params => generatePlotDataFunc[params.plotSpecificType](params);\nconst metricColors = {\n  confirmedCount: 'var(--primary-color-4)',\n  deadCount: 'var(--primary-color-10)',\n  curedCount: 'var(--primary-color-2)'\n};\nconst metricColorsDark = {\n  confirmedCount: 'var(--primary-color-4)',\n  deadCount: 'var(--lighter-grey)',\n  curedCount: 'var(--primary-color-2)'\n};\n\nconst generatePlotDataTotal = ({\n  data,\n  date,\n  currentRegion,\n  lang,\n  darkMode,\n  playing,\n  scale,\n  plotSpecificType,\n  plotDetails,\n  plotDates,\n  fullPlot\n}, fullData = false) => {\n  let maxValue = 0;\n  let minValue = 100000;\n  let plotData = ['deadCount', 'curedCount', 'confirmedCount'].map(metric => {\n    const counts = getDataFromRegion(data, currentRegion)[metric];\n    return {\n      id: metricText[metric][lang],\n      color: darkMode ? metricColorsDark[metric] : metricColors[metric],\n      data: Object.keys(counts).sort((a, b) => parseDate(a) > parseDate(b) ? 1 : -1).filter(d => !playing || parseDate(d) <= parseDate(date)).map(d => {\n        if (counts[d] > maxValue) maxValue = counts[d];\n        if (counts[d] < minValue) minValue = counts[d];\n        return scale === 'linear' || counts[d] > 0 ? {\n          x: d,\n          y: counts[d]\n        } : null;\n      }).filter(x => x != null)\n    };\n  });\n  plotData = calcMovingAverage(plotData, plotDetails.movingAverage);\n  if (!fullData) plotData = applyDateRange(plotData, plotDates);\n  return {\n    plotData,\n    ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue)\n  };\n};\n\nconst generatePlotDataNew = (params, fullData = false) => {\n  let {\n    plotData\n  } = generatePlotDataTotal(params, true);\n  plotData = convertTotalToNew(plotData);\n  if (!fullData) plotData = applyDateRange(plotData, params.plotDates);\n  return {\n    plotData\n  };\n};\n\nconst generatePlotDataGrowthRate = params => {\n  let {\n    plotData\n  } = params.plotSpecificType !== 'growth_new' ? generatePlotDataTotal(params, true) : generatePlotDataNew(params, true);\n  const metric = params.metric;\n  plotData.forEach(metricData => {\n    metricData.data = metricData.data.reduce((s, v, i) => [...s, metricData.data[i - 1] && metricData.data[i - 1].y > 0 ? { ...v,\n      y: (v.y - metricData.data[i - 1].y) / metricData.data[i - 1].y\n    } : { ...v,\n      y: 0\n    }], []);\n  });\n  if (metric === 'confirmedCount') plotData = [plotData[2]];\n  if (metric === 'curedCount') plotData = [plotData[1]];\n  if (metric === 'deadCount') plotData = [plotData[0]];\n  plotData = applyDateRange(plotData, params.plotDates);\n  return {\n    plotData\n  };\n};\n\nconst generatePlotDataDoublingTime = params => {\n  // set scale to log: temporary hack to remove zeros\n  let {\n    plotData\n  } = generatePlotDataGrowthRate({ ...params,\n    scale: 'log'\n  });\n  plotData[0].data = plotData[0].data.map(point => ({ ...point,\n    y: point.y > 0 ? Math.log(2) / Math.log(point.y + 1) : null,\n    lang: params.lang\n  })).filter(point => point.y != null && point.y < 1000); // remove outliers\n\n  return {\n    plotData\n  };\n};\n\nconst generatePlotDataR0 = params => {\n  // set scale to log: temporary hack to remove zeros\n  let {\n    plotData\n  } = generatePlotDataGrowthRate({ ...params,\n    metric: 'confirmedCount',\n    scale: 'log'\n  });\n  const t_incubation = 5;\n  const t_infectious = 5; // based on SEIR model\n  // R0 = (1 + lambda * t_incubation) * (1 + lambda * t_infectious)\n\n  plotData[0].data = plotData[0].data.map(point => ({ ...point,\n    y: (1 + Math.log(point.y + 1) * t_incubation) * (1 + Math.log(point.y + 1) * t_infectious),\n    lang: params.lang\n  })).filter(point => point.y < 20); // remove outliers\n\n  return {\n    plotData\n  };\n};\n\nconst generatePlotDataRate = ({\n  data,\n  currentRegion,\n  darkMode,\n  lang,\n  date,\n  playing,\n  plotDetails,\n  plotDates\n}) => {\n  const confirmedCounts = getDataFromRegion(data, currentRegion)['confirmedCount'];\n  const metrics = plotDetails.recoveryRate === 'show' ? ['deadCount', 'curedCount'] : ['deadCount'];\n  let plotData = metrics.map(metric => {\n    const counts = getDataFromRegion(data, currentRegion)[metric];\n    const newMetric = metric === 'deadCount' ? 'fatalityRate' : 'recoveryRate';\n    return {\n      id: metricText[newMetric][lang],\n      color: darkMode ? metricColorsDark[metric] : metricColors[metric],\n      data: Object.keys(counts).filter(d => !playing || parseDate(d) <= parseDate(date)).map(d => ({\n        d,\n        count: confirmedCounts[d] > 0 ? counts[d] / confirmedCounts[d] : 0\n      })).map(({\n        d,\n        count\n      }) => {\n        return {\n          x: d,\n          y: count\n        };\n      })\n    };\n  });\n  plotData = calcMovingAverage(plotData, plotDetails.movingAverage);\n  plotData = applyDateRange(plotData, plotDates);\n  return {\n    plotData\n  };\n};\n\nconst generatePlotDataOneVsRest = ({\n  data,\n  currentRegion,\n  metric,\n  lang,\n  date,\n  playing,\n  scale,\n  plotSpecificType,\n  plotDetails,\n  plotDates,\n  fullPlot\n}) => {\n  let maxValue = 0;\n  let minValue = 100000;\n  const currentData = getDataFromRegion(data, currentRegion);\n  const counts = currentData[metric];\n  let regionName = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH;\n  regionName = simplifyName(regionName, lang);\n  const parentRegion = currentRegion.length === 1 ? [str.GLOBAL_ZH] : currentRegion.slice(0, currentRegion.length - 1);\n  const parentData = getDataFromRegion(data, parentRegion);\n  const parentCounts = parentData[metric];\n  let parentRegionName = lang === 'zh' ? parentRegion[parentRegion.length - 1] : parentData.ENGLISH;\n  parentRegionName = simplifyName(parentRegionName, lang);\n  let plotData = [];\n  const parentPlotData = {\n    id: lang === 'zh' ? `${parentRegionName} (${i18n.REST[lang]})` : `${i18n.REST[lang]} of ${parentRegionName}`,\n    color: 'var(--primary-color-4)',\n    data: Object.keys(parentCounts).filter(d => !playing || parseDate(d) <= parseDate(date)).map(d => {\n      if (counts[d] == null) return null;\n      if (parentCounts[d] - counts[d] > maxValue) maxValue = parentCounts[d] - counts[d];\n      if (parentCounts[d] - counts[d] < minValue) minValue = parentCounts[d] - counts[d];\n      return scale === 'linear' || parentCounts[d] - counts[d] > 0 ? {\n        x: d,\n        y: parentCounts[d] - counts[d]\n      } : null;\n    }).filter(x => x != null)\n  };\n  const currentPlotData = {\n    id: regionName,\n    color: 'var(--primary-color-2)',\n    data: Object.keys(counts).filter(d => !playing || parseDate(d) <= parseDate(date)).map(d => {\n      if (parentCounts[d] == null) return null;\n      if (counts[d] > maxValue) maxValue = counts[d];\n      if (counts[d] < minValue) minValue = counts[d];\n      return scale === 'linear' || counts[d] > 0 ? {\n        x: d,\n        y: counts[d]\n      } : null;\n    }).filter(x => x != null)\n  };\n  plotData.push(parentPlotData);\n  plotData.push(currentPlotData);\n\n  if (plotSpecificType === 'one_vs_rest_new') {\n    plotData = convertTotalToNew(plotData);\n  }\n\n  plotData = calcMovingAverage(plotData, plotDetails.movingAverage);\n  plotData = applyDateRange(plotData, plotDates);\n  return {\n    plotData,\n    ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue)\n  };\n};\n\nconst generatePlotDataSubregionRankings = ({\n  data,\n  currentRegion,\n  metric,\n  lang,\n  darkMode,\n  playing,\n  date,\n  plotDates,\n  plotSpecificType\n}) => {\n  const currentData = getCurrentData(data, currentRegion);\n  const subregions = playing ? getSubregions(data, currentRegion, metric, 10) : getSubregions(data, currentRegion, metric, 10, date);\n  let regionIndices = {};\n  let dates = [];\n  let plotData = subregions.map((region, i) => {\n    dates = [...dates, ...Object.keys(currentData[region][metric])];\n    dates = [...new Set(dates)];\n    regionIndices[region] = i;\n    return region;\n  }).map((region, i) => {\n    const id = lang === 'zh' ? region : currentData[region].ENGLISH;\n    const dd = Object.keys(currentData[region][metric]).sort((a, b) => parseDate(a) > parseDate(b) ? 1 : -1).filter(d => parseDate(d) <= parseDate(date)).filter(d => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0]));\n    const counts = dd.map(d => currentData[region][metric][d]);\n    let count = counts[counts.length - 1];\n    if (plotSpecificType === 'most_affected_subregions_new') count = counts.length >= 2 ? counts[counts.length - 1] - counts[counts.length - 2] : counts[counts.length - 1];\n    return {\n      id: simplifyName(id, lang),\n      fullId: id,\n      name: region,\n      color: darkMode ? `var(--primary-color-${i < 7 ? i : i + 1})` : `var(--primary-color-${10 - i})`,\n      count,\n      data: []\n    };\n  });\n  dates = dates.sort((a, b) => parseDate(a) > parseDate(b) ? 1 : -1);\n  let regionSkipped = {};\n  dates.filter(d => parseDate(d) <= parseDate(date)).filter(d => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0])).forEach((d, i) => {\n    let regionCounts = [];\n    plotData.forEach(region => {\n      let counts = currentData[region.name][metric][d] ? currentData[region.name][metric][d] : 0;\n\n      if (plotSpecificType === 'most_affected_subregions_new') {\n        if (i > 0 && currentData[region.name][metric][dates[i - 1]]) counts = counts - currentData[region.name][metric][dates[i - 1]];\n      }\n\n      regionCounts.push({\n        region: region.name,\n        counts\n      });\n    });\n    regionCounts = regionCounts.sort((a, b) => a.counts <= b.counts ? 1 : -1);\n    regionCounts.forEach((region, i) => {\n      if (region.counts === 0 && regionSkipped[region.region] == null) {\n        plotData[regionIndices[region.region]].data.push({\n          x: d,\n          y: null\n        });\n      } else {\n        regionSkipped[region.region] = true;\n        plotData[regionIndices[region.region]].data.push({\n          x: d,\n          y: i + 1\n        });\n      }\n    });\n  });\n  return {\n    plotData,\n    dates\n  };\n};\n\nconst generatePlotDataSubregionStream = ({\n  data,\n  currentRegion,\n  lang,\n  playing,\n  date,\n  plotDates,\n  metric,\n  plotSpecificType,\n  fullPlot\n}) => {\n  const currentData = getCurrentData(data, currentRegion);\n  let dates = [];\n  let plotData = [];\n  const sortBy = plotSpecificType === 'subregion_active_stream' ? 'confirmedCount' : metric;\n  const numOfRegions = !fullPlot ? 5 : 9;\n  let subregionsData = getSubregions(data, currentRegion, sortBy, numOfRegions).map(region => {\n    dates = [...dates, ...Object.keys(currentData[region]['confirmedCount'])];\n    dates = [...new Set(dates)];\n    return region;\n  }).map(region => {\n    const id = lang === 'zh' ? region : currentData[region].ENGLISH;\n    return {\n      id: simplifyName(id, lang),\n      fullId: id,\n      name: region\n    };\n  });\n  let plotKeys = subregionsData.map(x => x.id); // at least (numOfRegions + 1) subregions\n\n  if (Object.keys(currentData).length >= numOfRegions + 5) plotKeys = [...plotKeys, i18n.OTHERS[lang]];\n  plotKeys = plotKeys.reverse();\n  dates = dates.sort((a, b) => parseDate(a) > parseDate(b) ? 1 : -1);\n  dates = dates.filter(d => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0])); // no subregions\n\n  if (subregionsData.length === 0) {\n    dates = Object.keys(currentData['confirmedCount']).sort((a, b) => parseDate(a) > parseDate(b) ? 1 : -1);\n    let id = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH;\n    id = simplifyName(id, lang);\n    plotKeys = [id];\n  }\n\n  dates.filter(d => !playing || parseDate(d) <= parseDate(date)).forEach((d, i) => {\n    let subregionCounts = {};\n    subregionsData.forEach(region => {\n      if (plotSpecificType === 'subregion_active_stream') {\n        const confirmedCount = currentData[region.name]['confirmedCount'][d] ? currentData[region.name]['confirmedCount'][d] : 0;\n        const deadCount = currentData[region.name]['deadCount'][d] ? currentData[region.name]['deadCount'][d] : 0;\n        const curedCount = currentData[region.name]['curedCount'][d] ? currentData[region.name]['curedCount'][d] : 0;\n        const remainingConfirmed = Math.max(confirmedCount - deadCount - curedCount, 0);\n        subregionCounts[region.id] = remainingConfirmed;\n      } else {\n        let count = currentData[region.name][metric][d] ? currentData[region.name][metric][d] : 0;\n        if (plotSpecificType === 'subregion_new_stream' && currentData[region.name][metric][dates[i - 1]]) count -= currentData[region.name][metric][dates[i - 1]];\n        subregionCounts[region.id] = count;\n      }\n    });\n    let otherConfirmedCount = 0;\n    let otherDeadCount = 0;\n    let otherCuredCount = 0; // compute number of remaining confirmed cases from non-top-5 subregions\n\n    Object.keys(currentData).filter(region => !['confirmedCount', 'deadCount', 'curedCount', 'ENGLISH', str.GLOBAL_ZH].includes(region)).filter(region => !subregionsData.map(x => x.name).includes(region)).forEach(region => {\n      const confirmedCount = currentData[region]['confirmedCount'][d] ? currentData[region]['confirmedCount'][d] : 0;\n      const deadCount = currentData[region]['deadCount'][d] ? currentData[region]['deadCount'][d] : 0;\n      const curedCount = currentData[region]['curedCount'][d] ? currentData[region]['curedCount'][d] : 0;\n      otherConfirmedCount += confirmedCount;\n      otherDeadCount += deadCount;\n      otherCuredCount += curedCount;\n\n      if (plotSpecificType === 'subregion_new_stream') {\n        const confirmedCountPrevious = currentData[region]['confirmedCount'][dates[i - 1]] ? currentData[region]['confirmedCount'][dates[i - 1]] : 0;\n        const deadCountPrevious = currentData[region]['deadCount'][dates[i - 1]] ? currentData[region]['deadCount'][dates[i - 1]] : 0;\n        const curedCountPrevious = currentData[region]['curedCount'][dates[i - 1]] ? currentData[region]['curedCount'][dates[i - 1]] : 0;\n        otherConfirmedCount -= confirmedCountPrevious;\n        otherDeadCount -= deadCountPrevious;\n        otherCuredCount -= curedCountPrevious;\n      }\n    });\n    let otherCount = 0;\n    if (metric === 'confirmedCount') otherCount = Math.max(otherConfirmedCount, 0);\n    if (metric === 'deadCount') otherCount = Math.max(otherDeadCount, 0);\n    if (metric === 'curedCount') otherCount = Math.max(otherCuredCount, 0);\n    if (plotSpecificType === 'subregion_active_stream') otherCount = Math.max(otherConfirmedCount - otherDeadCount - otherCuredCount, 0);\n    if (Object.keys(currentData).length >= 10) subregionCounts[i18n.OTHERS[lang]] = otherCount; // no subregions\n\n    if (subregionsData.length === 0) {\n      const confirmedCount = currentData['confirmedCount'][d] ? currentData['confirmedCount'][d] : 0;\n      const deadCount = currentData['deadCount'][d] ? currentData['deadCount'][d] : 0;\n      const curedCount = currentData['curedCount'][d] ? currentData['curedCount'][d] : 0;\n      const remainingConfirmed = Math.max(confirmedCount - deadCount - curedCount, 0);\n      let id = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH;\n      id = simplifyName(id, lang);\n      subregionCounts[id] = plotSpecificType === 'subregion_active_stream' ? remainingConfirmed : Math.max(currentData[metric][d] ? currentData[metric][d] : 0, 0);\n    }\n\n    plotData.push(subregionCounts);\n  });\n  return {\n    plotData,\n    dates,\n    plotKeys\n  };\n};\n\nconst generatePlotDataFatalityLine = ({\n  data,\n  currentRegion,\n  date,\n  darkMode,\n  lang,\n  plotSpecificType,\n  plotDates\n}) => {\n  const confirmedCount = getDataFromRegion(data, currentRegion)['confirmedCount'];\n  const deadCount = getDataFromRegion(data, currentRegion)['deadCount'];\n  const plotData = [{\n    id: 'fatality-line',\n    color: darkMode ? 'var(--primary-color-2)' : 'var(--primary-color-5)',\n    data: Object.keys(confirmedCount).filter(d => parseDate(d) <= parseDate(date) && confirmedCount[d] > 0 && (deadCount[d] > 0 || plotSpecificType === 'fatality_line' || plotSpecificType === 'fatality_line_only')).filter(d => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0])).map(d => ({\n      d,\n      cfr: deadCount[d] != null ? deadCount[d] / confirmedCount[d] : 0\n    })).map(({\n      d,\n      cfr\n    }) => {\n      return {\n        x: confirmedCount[d],\n        y: plotSpecificType === 'fatality_line' || plotSpecificType === 'fatality_line_only' ? cfr : deadCount[d],\n        date: d,\n        lang\n      };\n    })\n  }];\n  if (plotSpecificType === 'fatality_line' || plotSpecificType === 'fatality_line2') Object.keys(diseases).forEach(x => {\n    plotData.push({\n      id: x,\n      color: 'var(--light-grey)',\n      data: [{\n        x: diseases[x].confirmedCount,\n        y: plotSpecificType === 'fatality_line' ? diseases[x].deadCount / diseases[x].confirmedCount : diseases[x].deadCount,\n        lang,\n        name: diseases[x][lang],\n        years: diseases[x].years\n      }]\n    });\n  });\n  return {\n    plotData\n  };\n};\n\nconst generatePlotDataSubregionFatality = ({\n  data,\n  currentRegion,\n  date,\n  lang,\n  darkMode,\n  plotSpecificType\n}) => {\n  const currentData = getCurrentData(data, currentRegion);\n  let plotData = [];\n  let maxValue = 0;\n  let minValue = 100000;\n  getSubregions(data, currentRegion).reverse().filter(region => currentData[region]['confirmedCount'][date] > 0 && currentData[region]['deadCount'][date] >= 0 && (currentData[region]['deadCount'][date] > 0 || plotSpecificType === 'subregion_fatality' || plotSpecificType === 'subregion_fatality_only')).forEach((region, i) => {\n    const confirmedCount = currentData[region].confirmedCount[date];\n    const deadCount = currentData[region].deadCount[date];\n    maxValue = Math.max(maxValue, confirmedCount);\n    minValue = Math.min(minValue, confirmedCount);\n    plotData.push({\n      id: region,\n      color: darkMode ? 'rgba(222,73,104,0.6)' : 'rgba(183,55,121,0.5)',\n      data: [{\n        x: confirmedCount,\n        y: plotSpecificType === 'subregion_fatality' || plotSpecificType === 'subregion_fatality_only' ? deadCount / confirmedCount : deadCount,\n        regionName: lang === 'zh' ? region : currentData[region].ENGLISH,\n        lang\n      }]\n    });\n  });\n  if (plotSpecificType === 'subregion_fatality' || plotSpecificType === 'subregion_fatality2') Object.keys(diseases).forEach(x => {\n    plotData.push({\n      id: x,\n      color: 'rgba(0,0,0,0)',\n      data: [{\n        x: diseases[x].confirmedCount,\n        y: plotSpecificType === 'subregion_fatality' ? diseases[x].deadCount / diseases[x].confirmedCount : diseases[x].deadCount,\n        lang,\n        name: diseases[x][lang],\n        years: diseases[x].years,\n        noClick: true\n      }]\n    });\n  });\n  const {\n    logTickMin,\n    logTickMax\n  } = getLogTickValues(minValue, maxValue);\n  return {\n    plotData,\n    logTickMin,\n    logTickMax\n  };\n};\n\nconst generatePlotDataSubregion = ({\n  data,\n  date,\n  currentRegion,\n  lang,\n  darkMode,\n  playing,\n  scale,\n  metric,\n  plotSpecificType,\n  plotDetails,\n  plotDates,\n  fullPlot\n}) => {\n  const currentData = getCurrentData(data, currentRegion);\n  let maxValue = 0;\n  let minValue = 100000;\n  const numOfRegions = !fullPlot ? 6 : 10;\n  const subregions = playing ? getSubregions(data, currentRegion, metric, numOfRegions) : getSubregions(data, currentRegion, metric, numOfRegions, date);\n  let plotData = subregions.map((region, i) => {\n    const counts = currentData[region][metric];\n    const id = lang === 'zh' ? region : currentData[region].ENGLISH;\n    return {\n      id: simplifyName(id, lang),\n      fullId: id,\n      name: region,\n      color: darkMode ? `var(--primary-color-${i < 7 ? i : i + 1})` : `var(--primary-color-${10 - i})`,\n      data: Object.keys(counts).filter(d => !playing || parseDate(d) <= parseDate(date)).map(d => {\n        if (counts[d] > maxValue) maxValue = counts[d];\n        if (counts[d] < minValue) minValue = counts[d];\n        return scale === 'linear' || counts[d] > 0 ? {\n          x: d,\n          y: counts[d],\n          lang\n        } : null;\n      }).filter(x => x != null)\n    };\n  }).reverse();\n  if (['subregion_new', 'subregion_new_shifted_10', 'subregion_new_shifted_100'].includes(plotSpecificType)) plotData = convertTotalToNew(plotData);\n  plotData = calcMovingAverage(plotData, plotDetails.movingAverage);\n  plotData = applyDateRange(plotData, plotDates);\n  return {\n    plotData,\n    ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue)\n  };\n};\n\nconst generatePlotDataSubregionShifted = params => {\n  const {\n    scale,\n    plotSpecificType,\n    plotDetails,\n    fullPlot\n  } = params;\n  let {\n    plotData\n  } = generatePlotDataSubregion(params);\n  const shifted = parseInt(plotDetails.shifted, 10);\n  let maxValue = 0;\n  let minValue = 100000;\n  plotData.forEach(x => {\n    const firstIdx = x.data.findIndex(point => point.y >= shifted);\n\n    if (firstIdx === -1) {\n      x.data = [];\n    } else {\n      x.data = x.data.slice(firstIdx).map((point, i) => ({ ...point,\n        date: point.x,\n        x: i\n      }));\n    }\n\n    maxValue = x.data.reduce((s, point) => Math.max(s, point.y), maxValue);\n    minValue = x.data.reduce((s, point) => Math.min(s, point.y), minValue);\n  });\n  plotData = plotData.filter(x => x.data.length > 0);\n  return {\n    plotData,\n    ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue)\n  };\n};\n\nconst getCurrentData = (data, currentRegion) => {\n  const currentData = currentRegion.length === 1 && currentRegion[0] === str.GLOBAL_ZH ? data : getDataFromRegion(data, currentRegion);\n  return currentData;\n}; // convert cumulative dataset to daily increasement dataset\n\n\nconst convertTotalToNew = plotData => {\n  plotData.forEach(metricData => {\n    metricData.data = metricData.data.reduce((s, v, i) => [...s, metricData.data[i - 1] ? { ...v,\n      y: v.y - metricData.data[i - 1].y\n    } : v], []);\n  });\n  return plotData;\n}; // moving averages\n\n\nconst calcMovingAverage = (plotData, days) => {\n  if (days === '3d') {\n    plotData.forEach(metricData => {\n      metricData.data = metricData.data.reduce((s, v, i) => {\n        let newY = v.y;\n\n        if (metricData.data[i - 1] && metricData.data[i + 1]) {\n          newY = (metricData.data[i - 1].y + v.y + metricData.data[i + 1].y) / 3;\n        }\n\n        return [...s, { ...v,\n          y: newY\n        }];\n      }, []);\n    });\n  } else if (days === '5d') {\n    plotData.forEach(metricData => {\n      metricData.data = metricData.data.reduce((s, v, i) => {\n        let newY = v.y;\n\n        if (metricData.data[i - 1] && metricData.data[i - 2] && metricData.data[i + 1] && metricData.data[i + 2]) {\n          newY = (metricData.data[i - 2].y + metricData.data[i - 1].y + v.y + metricData.data[i + 1].y + metricData.data[i + 2].y) / 5;\n        } else if (metricData.data[i - 1] && metricData.data[i + 1]) {\n          newY = (metricData.data[i - 1].y + v.y + metricData.data[i + 1].y) / 3;\n        }\n\n        return [...s, { ...v,\n          y: newY\n        }];\n      }, []);\n    });\n  }\n\n  return plotData;\n}; // apply date range\n\n\nconst applyDateRange = (plotData, plotDates) => {\n  plotData.forEach(p => {\n    p.data = p.data.filter(x => parseDate(x.x) <= parseDate(plotDates[1]) && parseDate(x.x) >= parseDate(plotDates[0]));\n  });\n  return plotData;\n}; // data from top N subregions\n\n\nconst getSubregions = (data, currentRegion, metric = 'confirmedCount', topN = null, date = null) => {\n  const currentData = getCurrentData(data, currentRegion);\n  const subregions = Object.keys(currentData).filter(region => !['confirmedCount', 'deadCount', 'curedCount', 'ENGLISH', str.GLOBAL_ZH].includes(region)).sort((a, b) => {\n    let aCounts = Math.max(...Object.values(currentData[a][metric]));\n    let bCounts = Math.max(...Object.values(currentData[b][metric]));\n\n    if (date != null) {\n      aCounts = currentData[a][metric][date] ? currentData[a][metric][date] : 0;\n      bCounts = currentData[b][metric][date] ? currentData[b][metric][date] : 0;\n    }\n\n    return aCounts <= bCounts ? 1 : -1;\n  }); // top affected subregions\n\n  return topN != null ? subregions.filter((region, i) => i <= topN - 1 && Math.max(...Object.values(currentData[region][metric])) !== 0) : subregions;\n};\n\nconst getLogTickValues = (minValue, maxValue) => {\n  const logTickMin = minValue <= maxValue ? Math.max(10 ** Math.floor(Math.log10(minValue)), 1) : 1;\n  const logTickMax = minValue <= maxValue ? Math.max(10 ** Math.ceil(Math.log10(maxValue)), 10) : 1;\n  const tickValues = [...Array(Math.log10(logTickMax / logTickMin) + 1).keys()].map(x => 10 ** x * logTickMin);\n  return {\n    tickValues,\n    logTickMin,\n    logTickMax\n  };\n};\n\nconst getTickValues = (scale, plotSpecificType, fullPlot, minValue, maxValue) => {\n  return scale === 'log' && plotSpecificTypes[plotSpecificType].log ? getLogTickValues(minValue, maxValue) : {\n    tickValues: fullPlot ? 10 : 5,\n    logTickMin: 1,\n    logTickMax: 1\n  };\n};\n\nconst generatePlotDataFunc = {\n  total: generatePlotDataTotal,\n  new: generatePlotDataNew,\n  growth_total: generatePlotDataGrowthRate,\n  growth_new: generatePlotDataGrowthRate,\n  fatality_recovery: generatePlotDataRate,\n  one_vs_rest: generatePlotDataOneVsRest,\n  one_vs_rest_new: generatePlotDataOneVsRest,\n  most_affected_subregions: generatePlotDataSubregionRankings,\n  most_affected_subregions_new: generatePlotDataSubregionRankings,\n  subregion_active_stream: generatePlotDataSubregionStream,\n  fatality_line: generatePlotDataFatalityLine,\n  fatality_line2: generatePlotDataFatalityLine,\n  fatality_line_only: generatePlotDataFatalityLine,\n  fatality_line2_only: generatePlotDataFatalityLine,\n  doubling_time: generatePlotDataDoublingTime,\n  r0: generatePlotDataR0,\n  subregion_fatality: generatePlotDataSubregionFatality,\n  subregion_fatality2: generatePlotDataSubregionFatality,\n  subregion_fatality_only: generatePlotDataSubregionFatality,\n  subregion_fatality2_only: generatePlotDataSubregionFatality,\n  subregion_total: generatePlotDataSubregion,\n  subregion_new: generatePlotDataSubregion,\n  subregion_total_stream: generatePlotDataSubregionStream,\n  subregion_new_stream: generatePlotDataSubregionStream,\n  subregion_total_shifted_100: generatePlotDataSubregionShifted,\n  subregion_new_shifted_100: generatePlotDataSubregionShifted,\n  subregion_total_shifted_10: generatePlotDataSubregionShifted,\n  subregion_new_shifted_10: generatePlotDataSubregionShifted\n};","map":{"version":3,"sources":["/Users/jonchristie/Desktop/2020data/src/utils/plot_data.js"],"names":["getDataFromRegion","metricText","parseDate","simplifyName","str","plotSpecificTypes","i18n","diseases","generatePlotData","params","generatePlotDataFunc","plotSpecificType","metricColors","confirmedCount","deadCount","curedCount","metricColorsDark","generatePlotDataTotal","data","date","currentRegion","lang","darkMode","playing","scale","plotDetails","plotDates","fullPlot","fullData","maxValue","minValue","plotData","map","metric","counts","id","color","Object","keys","sort","a","b","filter","d","x","y","calcMovingAverage","movingAverage","applyDateRange","getTickValues","generatePlotDataNew","convertTotalToNew","generatePlotDataGrowthRate","forEach","metricData","reduce","s","v","i","generatePlotDataDoublingTime","point","Math","log","generatePlotDataR0","t_incubation","t_infectious","generatePlotDataRate","confirmedCounts","metrics","recoveryRate","newMetric","count","generatePlotDataOneVsRest","currentData","regionName","length","ENGLISH","parentRegion","GLOBAL_ZH","slice","parentData","parentCounts","parentRegionName","parentPlotData","REST","currentPlotData","push","generatePlotDataSubregionRankings","getCurrentData","subregions","getSubregions","regionIndices","dates","region","Set","dd","fullId","name","regionSkipped","regionCounts","generatePlotDataSubregionStream","sortBy","numOfRegions","subregionsData","plotKeys","OTHERS","reverse","subregionCounts","remainingConfirmed","max","otherConfirmedCount","otherDeadCount","otherCuredCount","includes","confirmedCountPrevious","deadCountPrevious","curedCountPrevious","otherCount","generatePlotDataFatalityLine","cfr","years","generatePlotDataSubregionFatality","min","noClick","logTickMin","logTickMax","getLogTickValues","generatePlotDataSubregion","generatePlotDataSubregionShifted","shifted","parseInt","firstIdx","findIndex","days","newY","p","topN","aCounts","values","bCounts","floor","log10","ceil","tickValues","Array","total","new","growth_total","growth_new","fatality_recovery","one_vs_rest","one_vs_rest_new","most_affected_subregions","most_affected_subregions_new","subregion_active_stream","fatality_line","fatality_line2","fatality_line_only","fatality_line2_only","doubling_time","r0","subregion_fatality","subregion_fatality2","subregion_fatality_only","subregion_fatality2_only","subregion_total","subregion_new","subregion_total_stream","subregion_new_stream","subregion_total_shifted_100","subregion_new_shifted_100","subregion_total_shifted_10","subregion_new_shifted_10"],"mappings":"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","sourcesContent":["import { getDataFromRegion, metricText, parseDate, simplifyName } from './utils'\nimport * as str from './strings'\nimport { plotSpecificTypes } from './plot_types'\nimport i18n from '../data/i18n.yml'\nimport diseases from '../data/other_diseases_stats.yml'\n\nexport const generatePlotData = (params) => generatePlotDataFunc[params.plotSpecificType](params)\n\nconst metricColors = {\n    confirmedCount: 'var(--primary-color-4)',\n    deadCount: 'var(--primary-color-10)',\n    curedCount: 'var(--primary-color-2)'\n}\n\nconst metricColorsDark = {\n    confirmedCount: 'var(--primary-color-4)',\n    deadCount: 'var(--lighter-grey)',\n    curedCount: 'var(--primary-color-2)'\n}\n\nconst generatePlotDataTotal = (\n    { data, date, currentRegion, lang, darkMode, playing, scale, plotSpecificType, plotDetails, plotDates, fullPlot },\n    fullData = false\n) => {\n    let maxValue = 0\n    let minValue = 100000\n\n    let plotData = [ 'deadCount', 'curedCount', 'confirmedCount' ].map((metric) => {\n        const counts = getDataFromRegion(data, currentRegion)[metric]\n        return {\n            id: metricText[metric][lang],\n            color: darkMode ? metricColorsDark[metric] : metricColors[metric],\n            data: Object.keys(counts)\n                .sort((a, b) => (parseDate(a) > parseDate(b) ? 1 : -1))\n                .filter((d) => !playing || parseDate(d) <= parseDate(date))\n                .map((d) => {\n                    if (counts[d] > maxValue) maxValue = counts[d]\n                    if (counts[d] < minValue) minValue = counts[d]\n\n                    return scale === 'linear' || counts[d] > 0\n                        ? {\n                              x: d,\n                              y: counts[d]\n                          }\n                        : null\n                })\n                .filter((x) => x != null)\n        }\n    })\n\n    plotData = calcMovingAverage(plotData, plotDetails.movingAverage)\n    if (!fullData) plotData = applyDateRange(plotData, plotDates)\n\n    return { plotData, ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue) }\n}\n\nconst generatePlotDataNew = (params, fullData = false) => {\n    let { plotData } = generatePlotDataTotal(params, true)\n\n    plotData = convertTotalToNew(plotData)\n    if (!fullData) plotData = applyDateRange(plotData, params.plotDates)\n\n    return { plotData }\n}\n\nconst generatePlotDataGrowthRate = (params) => {\n    let { plotData } =\n        params.plotSpecificType !== 'growth_new'\n            ? generatePlotDataTotal(params, true)\n            : generatePlotDataNew(params, true)\n    const metric = params.metric\n\n    plotData.forEach((metricData) => {\n        metricData.data = metricData.data.reduce(\n            (s, v, i) => [\n                ...s,\n                metricData.data[i - 1] && metricData.data[i - 1].y > 0\n                    ? { ...v, y: (v.y - metricData.data[i - 1].y) / metricData.data[i - 1].y }\n                    : { ...v, y: 0 }\n            ],\n            []\n        )\n    })\n\n    if (metric === 'confirmedCount') plotData = [ plotData[2] ]\n    if (metric === 'curedCount') plotData = [ plotData[1] ]\n    if (metric === 'deadCount') plotData = [ plotData[0] ]\n\n    plotData = applyDateRange(plotData, params.plotDates)\n\n    return { plotData }\n}\n\nconst generatePlotDataDoublingTime = (params) => {\n    // set scale to log: temporary hack to remove zeros\n    let { plotData } = generatePlotDataGrowthRate({ ...params, scale: 'log' })\n\n    plotData[0].data = plotData[0].data\n        .map((point) => ({\n            ...point,\n            y: point.y > 0 ? Math.log(2) / Math.log(point.y + 1) : null,\n            lang: params.lang\n        }))\n        .filter((point) => point.y != null && point.y < 1000) // remove outliers\n\n    return { plotData }\n}\n\nconst generatePlotDataR0 = (params) => {\n    // set scale to log: temporary hack to remove zeros\n    let { plotData } = generatePlotDataGrowthRate({ ...params, metric: 'confirmedCount', scale: 'log' })\n\n    const t_incubation = 5\n    const t_infectious = 5\n\n    // based on SEIR model\n    // R0 = (1 + lambda * t_incubation) * (1 + lambda * t_infectious)\n    plotData[0].data = plotData[0].data\n        .map((point) => ({\n            ...point,\n            y: (1 + Math.log(point.y + 1) * t_incubation) * (1 + Math.log(point.y + 1) * t_infectious),\n            lang: params.lang\n        }))\n        .filter((point) => point.y < 20) // remove outliers\n\n    return { plotData }\n}\n\nconst generatePlotDataRate = ({ data, currentRegion, darkMode, lang, date, playing, plotDetails, plotDates }) => {\n    const confirmedCounts = getDataFromRegion(data, currentRegion)['confirmedCount']\n\n    const metrics = plotDetails.recoveryRate === 'show' ? [ 'deadCount', 'curedCount' ] : [ 'deadCount' ]\n    let plotData = metrics.map((metric) => {\n        const counts = getDataFromRegion(data, currentRegion)[metric]\n        const newMetric = metric === 'deadCount' ? 'fatalityRate' : 'recoveryRate'\n        return {\n            id: metricText[newMetric][lang],\n            color: darkMode ? metricColorsDark[metric] : metricColors[metric],\n            data: Object.keys(counts)\n                .filter((d) => !playing || parseDate(d) <= parseDate(date))\n                .map((d) => ({ d, count: confirmedCounts[d] > 0 ? counts[d] / confirmedCounts[d] : 0 }))\n                .map(({ d, count }) => {\n                    return {\n                        x: d,\n                        y: count\n                    }\n                })\n        }\n    })\n\n    plotData = calcMovingAverage(plotData, plotDetails.movingAverage)\n    plotData = applyDateRange(plotData, plotDates)\n\n    return { plotData }\n}\n\nconst generatePlotDataOneVsRest = ({\n    data,\n    currentRegion,\n    metric,\n    lang,\n    date,\n    playing,\n    scale,\n    plotSpecificType,\n    plotDetails,\n    plotDates,\n    fullPlot\n}) => {\n    let maxValue = 0\n    let minValue = 100000\n\n    const currentData = getDataFromRegion(data, currentRegion)\n    const counts = currentData[metric]\n    let regionName = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH\n    regionName = simplifyName(regionName, lang)\n\n    const parentRegion =\n        currentRegion.length === 1 ? [ str.GLOBAL_ZH ] : currentRegion.slice(0, currentRegion.length - 1)\n    const parentData = getDataFromRegion(data, parentRegion)\n    const parentCounts = parentData[metric]\n    let parentRegionName = lang === 'zh' ? parentRegion[parentRegion.length - 1] : parentData.ENGLISH\n    parentRegionName = simplifyName(parentRegionName, lang)\n\n    let plotData = []\n\n    const parentPlotData = {\n        id: lang === 'zh' ? `${parentRegionName} (${i18n.REST[lang]})` : `${i18n.REST[lang]} of ${parentRegionName}`,\n        color: 'var(--primary-color-4)',\n        data: Object.keys(parentCounts)\n            .filter((d) => !playing || parseDate(d) <= parseDate(date))\n            .map((d) => {\n                if (counts[d] == null) return null\n\n                if (parentCounts[d] - counts[d] > maxValue) maxValue = parentCounts[d] - counts[d]\n                if (parentCounts[d] - counts[d] < minValue) minValue = parentCounts[d] - counts[d]\n\n                return scale === 'linear' || parentCounts[d] - counts[d] > 0\n                    ? {\n                          x: d,\n                          y: parentCounts[d] - counts[d]\n                      }\n                    : null\n            })\n            .filter((x) => x != null)\n    }\n\n    const currentPlotData = {\n        id: regionName,\n        color: 'var(--primary-color-2)',\n        data: Object.keys(counts)\n            .filter((d) => !playing || parseDate(d) <= parseDate(date))\n            .map((d) => {\n                if (parentCounts[d] == null) return null\n\n                if (counts[d] > maxValue) maxValue = counts[d]\n                if (counts[d] < minValue) minValue = counts[d]\n\n                return scale === 'linear' || counts[d] > 0\n                    ? {\n                          x: d,\n                          y: counts[d]\n                      }\n                    : null\n            })\n            .filter((x) => x != null)\n    }\n\n    plotData.push(parentPlotData)\n    plotData.push(currentPlotData)\n    if (plotSpecificType === 'one_vs_rest_new') {\n        plotData = convertTotalToNew(plotData)\n    }\n\n    plotData = calcMovingAverage(plotData, plotDetails.movingAverage)\n    plotData = applyDateRange(plotData, plotDates)\n\n    return { plotData, ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue) }\n}\n\nconst generatePlotDataSubregionRankings = ({\n    data,\n    currentRegion,\n    metric,\n    lang,\n    darkMode,\n    playing,\n    date,\n    plotDates,\n    plotSpecificType\n}) => {\n    const currentData = getCurrentData(data, currentRegion)\n    const subregions = playing\n        ? getSubregions(data, currentRegion, metric, 10)\n        : getSubregions(data, currentRegion, metric, 10, date)\n\n    let regionIndices = {}\n    let dates = []\n\n    let plotData = subregions\n        .map((region, i) => {\n            dates = [ ...dates, ...Object.keys(currentData[region][metric]) ]\n            dates = [ ...new Set(dates) ]\n            regionIndices[region] = i\n            return region\n        })\n        .map((region, i) => {\n            const id = lang === 'zh' ? region : currentData[region].ENGLISH\n            const dd = Object.keys(currentData[region][metric])\n                .sort((a, b) => (parseDate(a) > parseDate(b) ? 1 : -1))\n                .filter((d) => parseDate(d) <= parseDate(date))\n                .filter((d) => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0]))\n            const counts = dd.map((d) => currentData[region][metric][d])\n            let count = counts[counts.length - 1]\n            if (plotSpecificType === 'most_affected_subregions_new')\n                count =\n                    counts.length >= 2\n                        ? counts[counts.length - 1] - counts[counts.length - 2]\n                        : counts[counts.length - 1]\n            return {\n                id: simplifyName(id, lang),\n                fullId: id,\n                name: region,\n                color: darkMode ? `var(--primary-color-${i < 7 ? i : i + 1})` : `var(--primary-color-${10 - i})`,\n                count,\n                data: []\n            }\n        })\n\n    dates = dates.sort((a, b) => (parseDate(a) > parseDate(b) ? 1 : -1))\n\n    let regionSkipped = {}\n    dates\n        .filter((d) => parseDate(d) <= parseDate(date))\n        .filter((d) => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0]))\n        .forEach((d, i) => {\n            let regionCounts = []\n            plotData.forEach((region) => {\n                let counts = currentData[region.name][metric][d] ? currentData[region.name][metric][d] : 0\n                if (plotSpecificType === 'most_affected_subregions_new') {\n                    if (i > 0 && currentData[region.name][metric][dates[i - 1]])\n                        counts = counts - currentData[region.name][metric][dates[i - 1]]\n                }\n                regionCounts.push({\n                    region: region.name,\n                    counts\n                })\n            })\n            regionCounts = regionCounts.sort((a, b) => (a.counts <= b.counts ? 1 : -1))\n\n            regionCounts.forEach((region, i) => {\n                if (region.counts === 0 && regionSkipped[region.region] == null) {\n                    plotData[regionIndices[region.region]].data.push({\n                        x: d,\n                        y: null\n                    })\n                } else {\n                    regionSkipped[region.region] = true\n                    plotData[regionIndices[region.region]].data.push({\n                        x: d,\n                        y: i + 1\n                    })\n                }\n            })\n        })\n\n    return { plotData, dates }\n}\n\nconst generatePlotDataSubregionStream = ({\n    data,\n    currentRegion,\n    lang,\n    playing,\n    date,\n    plotDates,\n    metric,\n    plotSpecificType,\n    fullPlot\n}) => {\n    const currentData = getCurrentData(data, currentRegion)\n    let dates = []\n    let plotData = []\n\n    const sortBy = plotSpecificType === 'subregion_active_stream' ? 'confirmedCount' : metric\n    const numOfRegions = !fullPlot ? 5 : 9\n    let subregionsData = getSubregions(data, currentRegion, sortBy, numOfRegions)\n        .map((region) => {\n            dates = [ ...dates, ...Object.keys(currentData[region]['confirmedCount']) ]\n            dates = [ ...new Set(dates) ]\n            return region\n        })\n        .map((region) => {\n            const id = lang === 'zh' ? region : currentData[region].ENGLISH\n            return {\n                id: simplifyName(id, lang),\n                fullId: id,\n                name: region\n            }\n        })\n\n    let plotKeys = subregionsData.map((x) => x.id)\n\n    // at least (numOfRegions + 1) subregions\n    if (Object.keys(currentData).length >= numOfRegions + 5) plotKeys = [ ...plotKeys, i18n.OTHERS[lang] ]\n    plotKeys = plotKeys.reverse()\n\n    dates = dates.sort((a, b) => (parseDate(a) > parseDate(b) ? 1 : -1))\n    dates = dates.filter((d) => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0]))\n\n    // no subregions\n    if (subregionsData.length === 0) {\n        dates = Object.keys(currentData['confirmedCount']).sort((a, b) => (parseDate(a) > parseDate(b) ? 1 : -1))\n        let id = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH\n        id = simplifyName(id, lang)\n        plotKeys = [ id ]\n    }\n\n    dates.filter((d) => !playing || parseDate(d) <= parseDate(date)).forEach((d, i) => {\n        let subregionCounts = {}\n        subregionsData.forEach((region) => {\n            if (plotSpecificType === 'subregion_active_stream') {\n                const confirmedCount = currentData[region.name]['confirmedCount'][d]\n                    ? currentData[region.name]['confirmedCount'][d]\n                    : 0\n                const deadCount = currentData[region.name]['deadCount'][d]\n                    ? currentData[region.name]['deadCount'][d]\n                    : 0\n                const curedCount = currentData[region.name]['curedCount'][d]\n                    ? currentData[region.name]['curedCount'][d]\n                    : 0\n                const remainingConfirmed = Math.max(confirmedCount - deadCount - curedCount, 0)\n                subregionCounts[region.id] = remainingConfirmed\n            } else {\n                let count = currentData[region.name][metric][d] ? currentData[region.name][metric][d] : 0\n                if (plotSpecificType === 'subregion_new_stream' && currentData[region.name][metric][dates[i - 1]])\n                    count -= currentData[region.name][metric][dates[i - 1]]\n                subregionCounts[region.id] = count\n            }\n        })\n\n        let otherConfirmedCount = 0\n        let otherDeadCount = 0\n        let otherCuredCount = 0\n\n        // compute number of remaining confirmed cases from non-top-5 subregions\n        Object.keys(currentData)\n            .filter(\n                (region) => ![ 'confirmedCount', 'deadCount', 'curedCount', 'ENGLISH', str.GLOBAL_ZH ].includes(region)\n            )\n            .filter((region) => !subregionsData.map((x) => x.name).includes(region))\n            .forEach((region) => {\n                const confirmedCount = currentData[region]['confirmedCount'][d]\n                    ? currentData[region]['confirmedCount'][d]\n                    : 0\n                const deadCount = currentData[region]['deadCount'][d] ? currentData[region]['deadCount'][d] : 0\n                const curedCount = currentData[region]['curedCount'][d] ? currentData[region]['curedCount'][d] : 0\n                otherConfirmedCount += confirmedCount\n                otherDeadCount += deadCount\n                otherCuredCount += curedCount\n                if (plotSpecificType === 'subregion_new_stream') {\n                    const confirmedCountPrevious = currentData[region]['confirmedCount'][dates[i - 1]]\n                        ? currentData[region]['confirmedCount'][dates[i - 1]]\n                        : 0\n                    const deadCountPrevious = currentData[region]['deadCount'][dates[i - 1]]\n                        ? currentData[region]['deadCount'][dates[i - 1]]\n                        : 0\n                    const curedCountPrevious = currentData[region]['curedCount'][dates[i - 1]]\n                        ? currentData[region]['curedCount'][dates[i - 1]]\n                        : 0\n                    otherConfirmedCount -= confirmedCountPrevious\n                    otherDeadCount -= deadCountPrevious\n                    otherCuredCount -= curedCountPrevious\n                }\n            })\n        let otherCount = 0\n        if (metric === 'confirmedCount') otherCount = Math.max(otherConfirmedCount, 0)\n        if (metric === 'deadCount') otherCount = Math.max(otherDeadCount, 0)\n        if (metric === 'curedCount') otherCount = Math.max(otherCuredCount, 0)\n        if (plotSpecificType === 'subregion_active_stream')\n            otherCount = Math.max(otherConfirmedCount - otherDeadCount - otherCuredCount, 0)\n\n        if (Object.keys(currentData).length >= 10) subregionCounts[i18n.OTHERS[lang]] = otherCount\n\n        // no subregions\n        if (subregionsData.length === 0) {\n            const confirmedCount = currentData['confirmedCount'][d] ? currentData['confirmedCount'][d] : 0\n            const deadCount = currentData['deadCount'][d] ? currentData['deadCount'][d] : 0\n            const curedCount = currentData['curedCount'][d] ? currentData['curedCount'][d] : 0\n            const remainingConfirmed = Math.max(confirmedCount - deadCount - curedCount, 0)\n            let id = lang === 'zh' ? currentRegion[currentRegion.length - 1] : currentData.ENGLISH\n            id = simplifyName(id, lang)\n            subregionCounts[id] =\n                plotSpecificType === 'subregion_active_stream'\n                    ? remainingConfirmed\n                    : Math.max(currentData[metric][d] ? currentData[metric][d] : 0, 0)\n        }\n        plotData.push(subregionCounts)\n    })\n    return { plotData, dates, plotKeys }\n}\n\nconst generatePlotDataFatalityLine = ({ data, currentRegion, date, darkMode, lang, plotSpecificType, plotDates }) => {\n    const confirmedCount = getDataFromRegion(data, currentRegion)['confirmedCount']\n    const deadCount = getDataFromRegion(data, currentRegion)['deadCount']\n    const plotData = [\n        {\n            id: 'fatality-line',\n            color: darkMode ? 'var(--primary-color-2)' : 'var(--primary-color-5)',\n            data: Object.keys(confirmedCount)\n                .filter(\n                    (d) =>\n                        parseDate(d) <= parseDate(date) &&\n                        confirmedCount[d] > 0 &&\n                        (deadCount[d] > 0 ||\n                            plotSpecificType === 'fatality_line' ||\n                            plotSpecificType === 'fatality_line_only')\n                )\n                .filter((d) => parseDate(d) <= parseDate(plotDates[1]) && parseDate(d) >= parseDate(plotDates[0]))\n                .map((d) => ({ d, cfr: deadCount[d] != null ? deadCount[d] / confirmedCount[d] : 0 }))\n                .map(({ d, cfr }) => {\n                    return {\n                        x: confirmedCount[d],\n                        y:\n                            plotSpecificType === 'fatality_line' || plotSpecificType === 'fatality_line_only'\n                                ? cfr\n                                : deadCount[d],\n                        date: d,\n                        lang\n                    }\n                })\n        }\n    ]\n    if (plotSpecificType === 'fatality_line' || plotSpecificType === 'fatality_line2')\n        Object.keys(diseases).forEach((x) => {\n            plotData.push({\n                id: x,\n                color: 'var(--light-grey)',\n                data: [\n                    {\n                        x: diseases[x].confirmedCount,\n                        y:\n                            plotSpecificType === 'fatality_line'\n                                ? diseases[x].deadCount / diseases[x].confirmedCount\n                                : diseases[x].deadCount,\n                        lang,\n                        name: diseases[x][lang],\n                        years: diseases[x].years\n                    }\n                ]\n            })\n        })\n    return { plotData }\n}\n\nconst generatePlotDataSubregionFatality = ({ data, currentRegion, date, lang, darkMode, plotSpecificType }) => {\n    const currentData = getCurrentData(data, currentRegion)\n    let plotData = []\n    let maxValue = 0\n    let minValue = 100000\n\n    getSubregions(data, currentRegion)\n        .reverse()\n        .filter(\n            (region) =>\n                currentData[region]['confirmedCount'][date] > 0 &&\n                currentData[region]['deadCount'][date] >= 0 &&\n                (currentData[region]['deadCount'][date] > 0 ||\n                    plotSpecificType === 'subregion_fatality' ||\n                    plotSpecificType === 'subregion_fatality_only')\n        )\n        .forEach((region, i) => {\n            const confirmedCount = currentData[region].confirmedCount[date]\n            const deadCount = currentData[region].deadCount[date]\n            maxValue = Math.max(maxValue, confirmedCount)\n            minValue = Math.min(minValue, confirmedCount)\n\n            plotData.push({\n                id: region,\n                color: darkMode ? 'rgba(222,73,104,0.6)' : 'rgba(183,55,121,0.5)',\n                data: [\n                    {\n                        x: confirmedCount,\n                        y:\n                            plotSpecificType === 'subregion_fatality' || plotSpecificType === 'subregion_fatality_only'\n                                ? deadCount / confirmedCount\n                                : deadCount,\n                        regionName: lang === 'zh' ? region : currentData[region].ENGLISH,\n                        lang\n                    }\n                ]\n            })\n        })\n\n    if (plotSpecificType === 'subregion_fatality' || plotSpecificType === 'subregion_fatality2')\n        Object.keys(diseases).forEach((x) => {\n            plotData.push({\n                id: x,\n                color: 'rgba(0,0,0,0)',\n                data: [\n                    {\n                        x: diseases[x].confirmedCount,\n                        y:\n                            plotSpecificType === 'subregion_fatality'\n                                ? diseases[x].deadCount / diseases[x].confirmedCount\n                                : diseases[x].deadCount,\n                        lang,\n                        name: diseases[x][lang],\n                        years: diseases[x].years,\n                        noClick: true\n                    }\n                ]\n            })\n        })\n\n    const { logTickMin, logTickMax } = getLogTickValues(minValue, maxValue)\n\n    return { plotData, logTickMin, logTickMax }\n}\n\nconst generatePlotDataSubregion = ({\n    data,\n    date,\n    currentRegion,\n    lang,\n    darkMode,\n    playing,\n    scale,\n    metric,\n    plotSpecificType,\n    plotDetails,\n    plotDates,\n    fullPlot\n}) => {\n    const currentData = getCurrentData(data, currentRegion)\n    let maxValue = 0\n    let minValue = 100000\n\n    const numOfRegions = !fullPlot ? 6 : 10\n    const subregions = playing\n        ? getSubregions(data, currentRegion, metric, numOfRegions)\n        : getSubregions(data, currentRegion, metric, numOfRegions, date)\n\n    let plotData = subregions\n        .map((region, i) => {\n            const counts = currentData[region][metric]\n            const id = lang === 'zh' ? region : currentData[region].ENGLISH\n            return {\n                id: simplifyName(id, lang),\n                fullId: id,\n                name: region,\n                color: darkMode ? `var(--primary-color-${i < 7 ? i : i + 1})` : `var(--primary-color-${10 - i})`,\n                data: Object.keys(counts)\n                    .filter((d) => !playing || parseDate(d) <= parseDate(date))\n                    .map((d) => {\n                        if (counts[d] > maxValue) maxValue = counts[d]\n                        if (counts[d] < minValue) minValue = counts[d]\n\n                        return scale === 'linear' || counts[d] > 0\n                            ? {\n                                  x: d,\n                                  y: counts[d],\n                                  lang\n                              }\n                            : null\n                    })\n                    .filter((x) => x != null)\n            }\n        })\n        .reverse()\n\n    if ([ 'subregion_new', 'subregion_new_shifted_10', 'subregion_new_shifted_100' ].includes(plotSpecificType))\n        plotData = convertTotalToNew(plotData)\n\n    plotData = calcMovingAverage(plotData, plotDetails.movingAverage)\n    plotData = applyDateRange(plotData, plotDates)\n\n    return { plotData, ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue) }\n}\n\nconst generatePlotDataSubregionShifted = (params) => {\n    const { scale, plotSpecificType, plotDetails, fullPlot } = params\n\n    let { plotData } = generatePlotDataSubregion(params)\n\n    const shifted = parseInt(plotDetails.shifted, 10)\n    let maxValue = 0\n    let minValue = 100000\n    plotData.forEach((x) => {\n        const firstIdx = x.data.findIndex((point) => point.y >= shifted)\n\n        if (firstIdx === -1) {\n            x.data = []\n        } else {\n            x.data = x.data.slice(firstIdx).map((point, i) => ({\n                ...point,\n                date: point.x,\n                x: i\n            }))\n        }\n\n        maxValue = x.data.reduce((s, point) => Math.max(s, point.y), maxValue)\n        minValue = x.data.reduce((s, point) => Math.min(s, point.y), minValue)\n    })\n\n    plotData = plotData.filter((x) => x.data.length > 0)\n\n    return { plotData, ...getTickValues(scale, plotSpecificType, fullPlot, minValue, maxValue) }\n}\n\nconst getCurrentData = (data, currentRegion) => {\n    const currentData =\n        currentRegion.length === 1 && currentRegion[0] === str.GLOBAL_ZH ? data : getDataFromRegion(data, currentRegion)\n\n    return currentData\n}\n\n// convert cumulative dataset to daily increasement dataset\nconst convertTotalToNew = (plotData) => {\n    plotData.forEach((metricData) => {\n        metricData.data = metricData.data.reduce(\n            (s, v, i) => [ ...s, metricData.data[i - 1] ? { ...v, y: v.y - metricData.data[i - 1].y } : v ],\n            []\n        )\n    })\n\n    return plotData\n}\n\n// moving averages\nconst calcMovingAverage = (plotData, days) => {\n    if (days === '3d') {\n        plotData.forEach((metricData) => {\n            metricData.data = metricData.data.reduce((s, v, i) => {\n                let newY = v.y\n                if (metricData.data[i - 1] && metricData.data[i + 1]) {\n                    newY = (metricData.data[i - 1].y + v.y + metricData.data[i + 1].y) / 3\n                }\n                return [ ...s, { ...v, y: newY } ]\n            }, [])\n        })\n    } else if (days === '5d') {\n        plotData.forEach((metricData) => {\n            metricData.data = metricData.data.reduce((s, v, i) => {\n                let newY = v.y\n                if (\n                    metricData.data[i - 1] &&\n                    metricData.data[i - 2] &&\n                    metricData.data[i + 1] &&\n                    metricData.data[i + 2]\n                ) {\n                    newY =\n                        (metricData.data[i - 2].y +\n                            metricData.data[i - 1].y +\n                            v.y +\n                            metricData.data[i + 1].y +\n                            metricData.data[i + 2].y) /\n                        5\n                } else if (metricData.data[i - 1] && metricData.data[i + 1]) {\n                    newY = (metricData.data[i - 1].y + v.y + metricData.data[i + 1].y) / 3\n                }\n                return [ ...s, { ...v, y: newY } ]\n            }, [])\n        })\n    }\n\n    return plotData\n}\n\n// apply date range\nconst applyDateRange = (plotData, plotDates) => {\n    plotData.forEach((p) => {\n        p.data = p.data.filter(\n            (x) => parseDate(x.x) <= parseDate(plotDates[1]) && parseDate(x.x) >= parseDate(plotDates[0])\n        )\n    })\n\n    return plotData\n}\n\n// data from top N subregions\nconst getSubregions = (data, currentRegion, metric = 'confirmedCount', topN = null, date = null) => {\n    const currentData = getCurrentData(data, currentRegion)\n\n    const subregions = Object.keys(currentData)\n        .filter((region) => ![ 'confirmedCount', 'deadCount', 'curedCount', 'ENGLISH', str.GLOBAL_ZH ].includes(region))\n        .sort((a, b) => {\n            let aCounts = Math.max(...Object.values(currentData[a][metric]))\n            let bCounts = Math.max(...Object.values(currentData[b][metric]))\n            if (date != null) {\n                aCounts = currentData[a][metric][date] ? currentData[a][metric][date] : 0\n                bCounts = currentData[b][metric][date] ? currentData[b][metric][date] : 0\n            }\n\n            return aCounts <= bCounts ? 1 : -1\n        })\n\n    // top affected subregions\n    return topN != null\n        ? subregions.filter(\n              (region, i) => i <= topN - 1 && Math.max(...Object.values(currentData[region][metric])) !== 0\n          )\n        : subregions\n}\n\nconst getLogTickValues = (minValue, maxValue) => {\n    const logTickMin = minValue <= maxValue ? Math.max(10 ** Math.floor(Math.log10(minValue)), 1) : 1\n    const logTickMax = minValue <= maxValue ? Math.max(10 ** Math.ceil(Math.log10(maxValue)), 10) : 1\n    const tickValues = [ ...Array(Math.log10(logTickMax / logTickMin) + 1).keys() ].map((x) => 10 ** x * logTickMin)\n\n    return { tickValues, logTickMin, logTickMax }\n}\n\nconst getTickValues = (scale, plotSpecificType, fullPlot, minValue, maxValue) => {\n    return scale === 'log' && plotSpecificTypes[plotSpecificType].log\n        ? getLogTickValues(minValue, maxValue)\n        : { tickValues: fullPlot ? 10 : 5, logTickMin: 1, logTickMax: 1 }\n}\n\nconst generatePlotDataFunc = {\n    total: generatePlotDataTotal,\n    new: generatePlotDataNew,\n    growth_total: generatePlotDataGrowthRate,\n    growth_new: generatePlotDataGrowthRate,\n    fatality_recovery: generatePlotDataRate,\n    one_vs_rest: generatePlotDataOneVsRest,\n    one_vs_rest_new: generatePlotDataOneVsRest,\n    most_affected_subregions: generatePlotDataSubregionRankings,\n    most_affected_subregions_new: generatePlotDataSubregionRankings,\n    subregion_active_stream: generatePlotDataSubregionStream,\n    fatality_line: generatePlotDataFatalityLine,\n    fatality_line2: generatePlotDataFatalityLine,\n    fatality_line_only: generatePlotDataFatalityLine,\n    fatality_line2_only: generatePlotDataFatalityLine,\n    doubling_time: generatePlotDataDoublingTime,\n    r0: generatePlotDataR0,\n    subregion_fatality: generatePlotDataSubregionFatality,\n    subregion_fatality2: generatePlotDataSubregionFatality,\n    subregion_fatality_only: generatePlotDataSubregionFatality,\n    subregion_fatality2_only: generatePlotDataSubregionFatality,\n    subregion_total: generatePlotDataSubregion,\n    subregion_new: generatePlotDataSubregion,\n    subregion_total_stream: generatePlotDataSubregionStream,\n    subregion_new_stream: generatePlotDataSubregionStream,\n    subregion_total_shifted_100: generatePlotDataSubregionShifted,\n    subregion_new_shifted_100: generatePlotDataSubregionShifted,\n    subregion_total_shifted_10: generatePlotDataSubregionShifted,\n    subregion_new_shifted_10: generatePlotDataSubregionShifted\n}\n"]},"metadata":{},"sourceType":"module"}